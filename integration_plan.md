# NEAT Car AI Training System â€” Integration Plan

---

## 1. Project Overview

A desktop application for training self-driving car AI using the NEAT (NeuroEvolution of Augmenting Topologies) algorithm. Users can design circuits, configure car physics, tune NEAT hyperparameters, train AI agents with real-time visualization, and export trained models for head-to-head racing.

### Tech Stack

| Layer | Technology | Purpose |
|-------|-----------|---------|
| UI Window | PyWebView 6.x | Native desktop window with embedded browser |
| Frontend | Vanilla JS + HTML5 Canvas + CSS | Track drawing, car rendering, config panels |
| Backend | Python 3.10+ | Simulation, NEAT training, file I/O |
| Simulation | NumPy | Vectorized physics & raycasting for 300+ cars |
| AI | NEAT-Python >= 1.1.0 | Neuroevolution algorithm |
| Config | INI files | Car parameters + NEAT hyperparameters |
| Export | JSON | Trained genome + car config bundle |

### Dependencies

```
pip install pywebview neat-python numpy
```

Or with **uv** (recommended):

```bash
# Install uv (if not already installed)
curl -LsSf https://astral.sh/uv/install.sh | sh   # Linux/macOS
# or: powershell -c "irm https://astral.sh/uv/install.ps1 | iex"  # Windows

# Clone & run
git clone <repo>
cd neat-car-ai
uv sync                  # Install all dependencies from lock file
uv run main.py           # Launch the app

# Linux only: pywebview needs GTK or QT backend
# Ubuntu/Debian:
sudo apt install python3-gi python3-gi-cairo gir1.2-gtk-3.0 gir1.2-webkit2-4.1
```

---

## 2. Application Modes

### Mode 1: Track Editor

The user designs a circuit before training.

**Canvas:** Starts as full green (grass). User paints gray to create the road. Cars die when they leave the gray road (touch green).

**Features:**
- Paint road: draw gray road on green grass background with adjustable brush size
- Erase road: paint green back over gray to remove road sections
- Place/move start position (position + angle arrow)
- Place/move/reorder/delete checkpoints (ordered gate lines the car must pass through)
- Save track to `.track` file
- Load track from `.track` file
- Edit loaded track (continue painting, modify checkpoints, move start)
- Undo / Redo
- Clear all (reset to full green)

### Mode 2: Training

The user watches NEAT evolve car AI in real time.

**Features:**
- Start / Pause / Resume training
- Real-time visualization: all cars driving, rays visible (toggleable), alive/dead coloring
- Speed slider: 1x to 50x (controls sim steps per rendered frame)
- Live stats panel: generation #, alive count, best fitness, species count
- Fitness graph over generations (live-updating chart)
- Stop training â†’ export best genome
- Checkpoint saving every N generations (auto + manual)
- Resume from checkpoint with modified car config (speed, acceleration, etc.)
- Resume from checkpoint with modified NEAT config (only safe params: mutation rates, etc.)

### Mode 3: Race

The user loads multiple exported models and watches them race.

**Features:**
- Load a track file
- Import 2-10 exported racer packages (`.racer` JSON files)
- All models race simultaneously on the same track
- Each car rendered with distinct color/label
- Finish line = last checkpoint looped
- Leaderboard (time to complete N laps)
- Replay button

---

## 3. File Structure

```
neat-car-ai/
â”‚
â”œâ”€â”€ pyproject.toml                   # Project metadata + dependencies (uv managed)
â”œâ”€â”€ uv.lock                          # Locked dependencies (auto-generated by uv)
â”œâ”€â”€ .python-version                  # Python version pin (e.g. 3.12)
â”œâ”€â”€ main.py                          # Entry point: creates PyWebView window
â”œâ”€â”€ api.py                           # Python â†” JS bridge (exposed to JS)
â”œâ”€â”€ README.md                        # Setup instructions + usage guide
â”‚
â”œâ”€â”€ simulation/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ world.py                     # World: manages all cars, track, checkpoints
â”‚   â”œâ”€â”€ car.py                       # Car physics + ray sensors (vectorized)
â”‚   â”œâ”€â”€ track.py                     # Track: binary mask, collision, I/O
â”‚   â””â”€â”€ checkpoint.py                # Checkpoint gates logic
â”‚
â”œâ”€â”€ training/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ trainer.py                   # NEAT training loop (threaded)
â”‚   â”œâ”€â”€ fitness_evaluator.py         # User-defined fitness: exec + CarStats + validation
â”‚   â”œâ”€â”€ exporter.py                  # Save/load genome + car config as .racer
â”‚   â””â”€â”€ config_bridge.py             # Generate NEAT config file from UI values
â”‚
â”œâ”€â”€ race/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ race_manager.py              # Load racers, run race, track results
â”‚
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ car_config.ini               # Default car parameters
â”‚   â””â”€â”€ neat_config.ini              # Default NEAT hyperparameters
â”‚
â”œâ”€â”€ web/
â”‚   â”œâ”€â”€ index.html                   # Main HTML layout (all modes)
â”‚   â”œâ”€â”€ style.css                    # Full application styling
â”‚   â”‚
â”‚   â”œâ”€â”€ js/
â”‚   â”‚   â”œâ”€â”€ app.js                   # App state, mode switching, init
â”‚   â”‚   â”œâ”€â”€ canvas.js                # Canvas rendering (cars, rays, track)
â”‚   â”‚   â”œâ”€â”€ editor.js                # Track editor tools (draw, checkpoints, start)
â”‚   â”‚   â”œâ”€â”€ training.js              # Training UI controls + stats display
â”‚   â”‚   â”œâ”€â”€ race.js                  # Race mode UI + results
â”‚   â”‚   â”œâ”€â”€ config_panel.js          # Car & NEAT config forms
â”‚   â”‚   â”œâ”€â”€ fitness_editor.js        # Fitness function code editor + validation
â”‚   â”‚   â””â”€â”€ chart.js                 # Fitness chart over generations
â”‚   â”‚
â”‚   â””â”€â”€ assets/
â”‚       â””â”€â”€ default_car.png          # Default car sprite
â”‚
â”œâ”€â”€ tracks/                          # Saved track files
â”‚   â””â”€â”€ example_oval.track
â”‚
â”œâ”€â”€ exports/                         # Exported trained models
â”‚   â””â”€â”€ (*.racer files)
â”‚
â””â”€â”€ checkpoints/                     # NEAT training checkpoints
    â””â”€â”€ (*.checkpoint files)

â”œâ”€â”€ tests/                           # Unit tests
â”‚   â”œâ”€â”€ test_track.py                # Track loading, collision, raycasting
â”‚   â”œâ”€â”€ test_car.py                  # Physics, drift, vectorized updates
â”‚   â”œâ”€â”€ test_checkpoint.py           # Gate intersection logic
â”‚   â”œâ”€â”€ test_fitness.py              # FitnessEvaluator validation, exec safety
â”‚   â””â”€â”€ test_exporter.py             # Genome serialization round-trip
```

---

## 4. Configuration Files

### 4.0 `pyproject.toml` (uv managed)

```toml
[project]
name = "neat-car-ai"
version = "1.0.0"
description = "Train self-driving car AI using NEAT neuroevolution"
readme = "README.md"
requires-python = ">=3.10"
dependencies = [
    "pywebview>=5.0",
    "neat-python>=1.1.0",
    "numpy>=1.24",
]

[project.scripts]
neat-car-ai = "main:main"
```

**Usage:**
```bash
uv run main.py           # Run the app
uv run neat-car-ai       # Run via script entry point
uv sync                  # Install/sync dependencies from lock file
uv add <package>         # Add a new dependency
```

### 4.1 Car Configuration (`config/car_config.ini`)

```ini
[car]
# Identity
name = MyCar

# Physics
max_speed = 10.0
acceleration = 0.5
brake_force = 0.8
rotation_speed = 4.0

# Drift
drift_enabled = False
grip = 0.7

# Sensors (raycasts)
ray_count = 5
ray_length = 200
ray_spread_angle = 180
# Angles are evenly spread: for 5 rays at 180Â°, angles = [-90, -45, 0, 45, 90]
# Or manually specified:
# ray_angles = -90, -45, 0, 45, 90

# Appearance
car_image = assets/default_car.png
# NOTE: car_width (30) and car_height (15) are fixed constants
# and cannot be changed â€” ensures fair hitboxes in races

# Training timing
max_ticks = 2000
stall_timeout = 200
# max_ticks: maximum ticks per generation before timeout (all cars killed)
# stall_timeout: kill a car after N ticks without crossing a checkpoint
```

**Notes:**
- Neural network inputs (always): `ray_count` ray distances + current speed + heading angle + acceleration state
- Additional input when `drift_enabled = True`: drift angle (heading vs velocity direction)
- `num_inputs` = `ray_count + 3` (drift off) or `ray_count + 4` (drift on)
- Changing `ray_count` or `drift_enabled` is **NOT** compatible with resume (changes network topology)
- All other parameters (max_speed, acceleration, brake_force, rotation_speed, grip) CAN be changed between stop/resume
- `grip` is only used when `drift_enabled = True`, but can be changed freely on resume
- `car_width` (30) and `car_height` (15) are **hardcoded constants** â€” not in config, ensures fair hitboxes across all races
- `max_ticks` and `stall_timeout` control generation timing â€” can be changed freely on resume
- `ray_length` and `ray_spread_angle` CAN be changed on resume (don't affect topology) but will confuse existing genomes â€” UI should show a âš ï¸ warning: "Changing sensor range mid-training may degrade performance"
- `pop_size` CAN be changed on resume but `neat-python` will create/remove genomes â€” UI should warn: "Changing population size will add/remove genomes"

### 4.2 NEAT Configuration (`config/neat_config.ini`)

```ini
[NEAT]
fitness_criterion = max
fitness_threshold = 100000
pop_size = 200
reset_on_extinction = True
no_fitness_termination = True

[DefaultGenome]
# Network topology
num_inputs = 8
# Auto-calculated: ray_count + 3 (no drift) or ray_count + 4 (drift)
# With 5 rays, no drift: 5 + 3 = 8
# Inputs: [ray1..rayN, speed, heading, accel_state, (drift_angle)]
num_outputs = 2
num_hidden = 0
feed_forward = True
initial_connection = full_direct

# Activation
activation_default = tanh
activation_mutate_rate = 0.0
activation_options = tanh

# Node add/remove
node_add_prob = 0.2
node_delete_prob = 0.1

# Connection add/remove
conn_add_prob = 0.5
conn_delete_prob = 0.3

# Weight mutation
weight_max_value = 30
weight_min_value = -30
weight_init_mean = 0.0
weight_init_stdev = 1.0
weight_init_type = gaussian
weight_mutate_power = 0.5
weight_mutate_rate = 0.8
weight_replace_rate = 0.1

# Bias mutation
bias_max_value = 30
bias_min_value = -30
bias_init_mean = 0.0
bias_init_stdev = 1.0
bias_init_type = gaussian
bias_mutate_power = 0.5
bias_mutate_rate = 0.7
bias_replace_rate = 0.1

# Response mutation
response_init_mean = 1.0
response_init_stdev = 0.0
response_init_type = gaussian
response_max_value = 30.0
response_min_value = -30.0
response_mutate_power = 0.0
response_mutate_rate = 0.0
response_replace_rate = 0.0

# Connection enable/disable
enabled_default = True
enabled_mutate_rate = 0.01

# Compatibility (speciation)
compatibility_disjoint_coefficient = 1.0
compatibility_weight_coefficient = 0.5

[DefaultSpeciesSet]
compatibility_threshold = 3.0

[DefaultStagnation]
species_fitness_func = max
max_stagnation = 20
species_elitism = 2

[DefaultReproduction]
elitism = 2
survival_threshold = 0.2
min_species_size = 2
```

**Notes:**
- `num_inputs` is auto-set from `car_config.ray_count` â€” user does NOT edit this
- `num_outputs` is always 2 (steering, acceleration) â€” user does NOT edit this
- User edits: `pop_size`, mutation rates, compatibility, stagnation, reproduction params

### 4.3 Track File Format (`.track`)

```json
{
  "version": 1,
  "width": 1200,
  "height": 800,
  "road_mask_base64": "<base64 encoded road mask PNG â€” gray pixels = road, green = grass>",
  "start": {
    "x": 100,
    "y": 400,
    "angle": 0
  },
  "checkpoints": [
    {"x1": 200, "y1": 350, "x2": 200, "y2": 450},
    {"x1": 500, "y1": 300, "x2": 500, "y2": 400},
    {"x1": 800, "y1": 350, "x2": 800, "y2": 450}
  ]
}
```

### 4.4 Racer Export Format (`.racer`)

```json
{
  "version": 1,
  "name": "MyCar_Gen42",
  "exported_at": "2026-02-09T14:30:00Z",
  "car_config": {
    "name": "MyCar",
    "max_speed": 10.0,
    "acceleration": 0.5,
    "brake_force": 0.8,
    "rotation_speed": 4.0,
    "drift_enabled": false,
    "grip": 0.7,
    "ray_count": 5,
    "ray_length": 200,
    "ray_spread_angle": 180
  },
  "genome": {
    "key": 42,
    "fitness": 8945.2,
    "nodes": [
      {"key": 0, "bias": 0.5, "activation": "tanh", "response": 1.0},
      ...
    ],
    "connections": [
      {"key": [-1, 0], "weight": 1.23, "enabled": true},
      ...
    ]
  },
  "generation": 42,
  "species_count": 8,
  "training_track": "example_oval.track",
  "fitness_code": "def fitness(car):\n    score = 0.0\n    score += car.total_checkpoints * 1000\n    ..."
}
```

---

## 5. Python Classes & Functions

### 5.1 `main.py` â€” Entry Point

```
main()
    Creates Api instance
    Creates PyWebView window pointing to web/index.html
    Exposes Api as js_api
    Starts PyWebView
```

### 5.2 `api.py` â€” Python â†” JS Bridge

```python
class Api:
    """Exposed to JavaScript via pywebview.api"""

    # === Track Editor ===
    save_track(track_json: str) -> dict              # Save track to .track file
    load_track(filepath: str) -> dict                 # Load track from .track file
    list_tracks() -> list[str]                        # List saved tracks
    delete_track(filepath: str) -> bool

    # === Config ===
    get_car_config() -> dict                          # Read car_config.ini as dict
    set_car_config(config: dict) -> bool              # Write dict to car_config.ini
    get_neat_config() -> dict                         # Read neat_config.ini as dict
    set_neat_config(config: dict) -> bool             # Write dict to neat_config.ini
    validate_config_for_resume(config: dict) -> dict  # Check compatibility

    # === Fitness Function ===
    get_fitness_code() -> str                         # Get current fitness function source
    set_fitness_code(code: str) -> dict               # Validate & set. Returns {valid, error?}
    reset_fitness_code() -> str                       # Reset to default, returns source

    # === Training ===
    start_training(track_json: str) -> dict           # Start NEAT training (new)
    # Validates before starting:
    # - Track has at least 1 checkpoint â†’ error: "Place at least one checkpoint"
    # - Track has a start position â†’ error: "Place a start position"
    # - Start position is on road (not grass) â†’ error: "Start position is on grass"
    # Returns {"success": True} or {"success": False, "error": "..."}
    resume_training(checkpoint_path: str) -> bool     # Resume from checkpoint
    pause_training() -> bool                          # Pause (can resume)
    stop_training() -> bool                           # Stop completely
    set_speed(steps_per_frame: int) -> bool           # Set simulation speed
    get_training_state() -> dict                      # Poll: car positions, stats
    toggle_rays(visible: bool) -> bool                # Toggle ray visualization
    save_checkpoint() -> str                          # Manual checkpoint save
    list_checkpoints() -> list[dict]                  # List available checkpoints

    # === Export ===
    export_best_racer(name: str = None) -> str  # Export best genome as .racer (defaults to car name)
    list_racers() -> list[dict]                       # List exported racers

    # === Race ===
    start_race(track_path: str, racers: list, num_laps: int = 3) -> bool
    get_race_state() -> dict                          # Poll: car positions, rankings
    stop_race() -> bool

    # === File Dialogs ===
    open_file_dialog(filetypes: list) -> str          # Native file picker
    save_file_dialog(filename: str) -> str            # Native save dialog
```

### 5.3 `simulation/track.py` â€” Track

```python
class Track:
    """Road mask representation of the circuit.
    The mask is a boolean array: True = grass (death), False = road (safe)."""

    # Properties
    width: int                              # Track canvas width in pixels
    height: int                             # Track canvas height in pixels
    road_mask: np.ndarray                   # Shape (H, W), dtype bool â€” True = grass, False = road
    start_pos: tuple[float, float]          # (x, y)
    start_angle: float                      # Radians
    checkpoints: list[Checkpoint]           # Ordered checkpoint gates

    # Construction
    from_road_base64(data: str, w, h) -> Track       # Load from base64 road mask PNG
    from_json(track_json: dict) -> Track              # Load from .track file dict

    # Serialization
    to_json() -> dict                                # Export as .track dict
    save(filepath: str)                              # Save to .track file
    load(filepath: str) -> Track                     # Class method: load .track file

    # Queries
    is_grass(x: int, y: int) -> bool                 # Single point check (True = death)
    is_grass_batch(xs: np.ndarray, ys: np.ndarray) -> np.ndarray  # Vectorized check
    raycast_batch(
        positions: np.ndarray,           # (N, 2) car positions
        angles: np.ndarray,              # (N,) car headings
        ray_offsets: np.ndarray,         # (R,) ray angle offsets
        max_length: float                # Max ray distance
    ) -> np.ndarray                      # (N, R) distances per car per ray
```

### 5.4 `simulation/checkpoint.py` â€” Checkpoint

```python
class Checkpoint:
    """A gate defined by two endpoints (a line segment)"""

    x1: float
    y1: float
    x2: float
    y2: float
    index: int                              # Order in the circuit

    intersects_segment(
        px: float, py: float,               # Start of movement
        qx: float, qy: float               # End of movement
    ) -> bool                               # Did the car cross this gate?

    # Vectorized: check all cars against this checkpoint
    intersects_batch(
        old_positions: np.ndarray,          # (N, 2)
        new_positions: np.ndarray           # (N, 2)
    ) -> np.ndarray                         # (N,) bool
```

### 5.5 `simulation/car.py` â€” Vectorized Car Physics

```python
class CarConfig:
    """Loaded from car_config.ini"""

    # Identity
    name: str                               # Car/racer name (used in exports + race labels)

    # Fixed constants (same for all cars â€” ensures fair races)
    CAR_WIDTH: int = 30                     # Pixels â€” NOT configurable
    CAR_HEIGHT: int = 15                    # Pixels â€” NOT configurable

    # Configurable physics
    max_speed: float
    acceleration: float
    brake_force: float
    rotation_speed: float
    drift_enabled: bool
    grip: float                             # Only used when drift_enabled = True
    ray_count: int
    ray_length: float
    ray_spread_angle: float
    ray_angles: np.ndarray                  # Precomputed from count + spread
    car_image: str

    # Training timing
    max_ticks: int                          # Max ticks per generation (timeout)
    stall_timeout: int                      # Kill car after N ticks without checkpoint

    @classmethod
    from_ini(filepath: str) -> CarConfig
    to_dict() -> dict
    is_topology_compatible(other: CarConfig) -> bool  # Check ray_count + drift_enabled match


class CarBatch:
    """Vectorized state for ALL cars in a generation"""

    count: int                              # Number of cars
    positions: np.ndarray                   # (N, 2) â€” x, y
    angles: np.ndarray                      # (N,) â€” heading in radians (where car points)
    velocity_angles: np.ndarray             # (N,) â€” velocity direction (where car moves)
    speeds: np.ndarray                      # (N,) â€” current speed
    prev_speeds: np.ndarray                 # (N,) â€” speed from previous tick (for accel state)
    alive: np.ndarray                       # (N,) â€” bool, alive or crashed
    fitness: np.ndarray                     # (N,) â€” accumulated fitness
    checkpoint_progress: np.ndarray         # (N,) â€” int, next checkpoint index
    total_checkpoints: np.ndarray           # (N,) â€” int, total checkpoints crossed (across laps)
    laps: np.ndarray                        # (N,) â€” int, full laps completed
    time_alive: np.ndarray                  # (N,) â€” ticks survived
    stall_timer: np.ndarray                 # (N,) â€” ticks since last checkpoint
    total_distance: np.ndarray              # (N,) â€” odometer
    max_speed_reached: np.ndarray           # (N,) â€” peak speed
    speed_accumulator: np.ndarray           # (N,) â€” sum of speeds (for average)
    drift_count: np.ndarray                 # (N,) â€” ticks spent drifting
    crashed: np.ndarray                     # (N,) â€” bool, died by hitting grass
    timed_out: np.ndarray                   # (N,) â€” bool, died by stall timeout
    wall_hits: np.ndarray                   # (N,) â€” ticks spent grazing grass edge
    min_wall_distance: np.ndarray           # (N,) â€” closest approach to grass
    wall_distance_accumulator: np.ndarray   # (N,) â€” sum of nearest wall distances (for avg)
    distance_to_next_cp: np.ndarray         # (N,) â€” distance to next checkpoint center

    # Initialization
    reset(count: int, start_pos, start_angle)  # Reset all cars to start

    # Physics update (vectorized â€” all cars at once)
    update(
        steering: np.ndarray,               # (N,) â€” from NEAT: -1 (left) to 1 (right)
        throttle: np.ndarray,               # (N,) â€” from NEAT: -1 (brake) to 1 (accel)
        config: CarConfig
    )
    # Steps:
    # 1. Store prev_speeds = speeds.copy()
    # 2. Apply steering: angles += steering * rotation_speed * alive
    # 3. Apply throttle: speeds += throttle * acceleration * alive
    #    (positive throttle = accelerate, negative = brake)
    # 4. Apply braking: if throttle < 0: speeds -= brake_force * abs(throttle)
    # 5. Clamp speeds to [0, max_speed]
    # 6. If drift_enabled:
    #        velocity_angles += (angles - velocity_angles) * grip
    #        x += cos(velocity_angle) * speed
    #        y += sin(velocity_angle) * speed
    #    Else:
    #        velocity_angles = angles  (instant match)
    #        x += cos(angle) * speed
    #        y += sin(angle) * speed

    # Collision & checkpoint
    check_grass(track: Track)               # Kill cars that touch grass, set crashed=True
    check_checkpoints(checkpoints: list)    # Update progress, laps, total_checkpoints
    check_stall(max_stall: int)             # Kill cars stalled too long, set timed_out=True
    update_wall_stats(track: Track)         # Track min/avg wall distance, wall_hits per tick
    # Uses shortest ray distance as proxy for wall distance
    # wall_hit = any ray distance < threshold (e.g. 5px)
    update_distance_to_cp(checkpoints: list)  # Update distance to next checkpoint center
    # Uses Euclidean distance from car position to midpoint of next gate

    # Neural network inputs (vectorized)
    get_nn_inputs(track: Track, config: CarConfig) -> np.ndarray  # (N, num_inputs)
    # Builds input array per car:
    # - ray distances: (N, ray_count) normalized [0, 1]
    # - speed: (N, 1) normalized to [0, 1] by max_speed
    # - heading: (N, 1) normalized to [-1, 1] (angle / pi)
    # - accel_state: (N, 1) = (speed - prev_speed) / acceleration, clamped [-1, 1]
    # - drift_angle (if drift_enabled): (N, 1) = (angle - velocity_angle) / pi, clamped [-1, 1]
    # Total: (N, ray_count + 3) or (N, ray_count + 4) with drift

    # State export (for rendering)
    get_state_dict() -> dict                # Compact dict for JS rendering
```

### 5.6 `simulation/world.py` â€” World Manager

```python
class World:
    """Manages one generation of cars on a track"""

    track: Track
    car_config: CarConfig
    cars: CarBatch
    generation: int
    tick: int
    max_ticks: int                          # From car_config.max_ticks
    stall_timeout: int                      # From car_config.stall_timeout

    # Setup
    __init__(track: Track, car_config: CarConfig)
    reset_generation(count: int)             # Reset all cars to start position

    # Simulation step (called many times per rendered frame)
    step(
        networks: list,                      # NEAT neural networks, one per car
    ) -> bool                                # Returns False when all dead or timeout
    # Internally:
    # 1. inputs = cars.get_nn_inputs(track, car_config) â†’ (N, num_inputs)
    # 2. For each alive car: net.activate(inputs[i]) â†’ [steering, throttle]
    # 3. cars.update(steering, throttle, car_config)
    # 4. cars.check_grass(track)
    # 5. cars.check_checkpoints(track.checkpoints)
    # 6. cars.update_wall_stats(track)
    # 7. cars.update_distance_to_cp(track.checkpoints)
    # 8. cars.check_stall(stall_timeout)
    # 8. cars.update_tracking_stats() â€” odometer, speed accum, drift count, etc.
    # 9. tick += 1, check timeout
    # NOTE: fitness is NOT computed here â€” it's evaluated after the generation
    #       ends, using FitnessEvaluator on CarStats snapshots

    # State
    all_dead() -> bool
    get_state() -> dict                      # For JS rendering
    build_car_stats() -> list[CarStats]      # Build CarStats from CarBatch arrays for FitnessEvaluator
```

### 5.7 `training/trainer.py` â€” NEAT Training Loop

```python
class Trainer:
    """Runs NEAT evolution in a background thread"""

    # State
    running: bool                            # Currently training?
    paused: bool                             # Paused?
    generation: int
    best_fitness: float
    best_genome: neat.DefaultGenome
    fitness_evaluator: FitnessEvaluator      # User-defined fitness function
    history: list[dict]                      # Per-generation stats for chart
    speed: int                               # Sim steps per frame (1-50)
    show_rays: bool                          # Send ray data to JS?

    # Thread-safe state for JS polling
    _lock: threading.Lock
    _current_state: dict                     # Latest snapshot for get_training_state()

    # Lifecycle
    start(
        track: Track,
        car_config: CarConfig,
        neat_config_path: str
    )
    # Steps:
    # 1. Load NEAT config
    # 2. Override num_inputs from car_config.ray_count
    # 3. Override num_outputs = 2
    # 4. Create neat.Population
    # 5. Add reporters: StdOutReporter, StatisticsReporter, Checkpointer
    # 6. Launch _training_thread

    resume(
        checkpoint_path: str,
        car_config: CarConfig,               # Possibly modified
        neat_config_path: str                 # Possibly modified
    )
    # Steps:
    # 1. Load checkpoint â†’ neat.Checkpointer.restore_checkpoint()
    # 2. Validate topology compatibility (ray_count unchanged)
    # 3. Apply new car_config to world
    # 4. Launch _training_thread

    pause()                                  # Set paused flag
    unpause()                                # Clear paused flag
    stop()                                   # Set running = False, wait for thread

    # Internal
    _training_thread()
    # Main loop:
    # while running:
    #     if paused: sleep and continue
    #     population.run(eval_genomes, 1)     # Run 1 generation
    #     Update history + stats
    #     Auto-checkpoint every N gens

    _eval_genomes(genomes, config)
    # Called by NEAT per generation:
    # 1. world.reset_generation(len(genomes))
    # 2. Create networks: [neat.nn.FeedForwardNetwork.create(g, config) for g in genomes]
    # 3. Loop: while not world.all_dead() and tick < max:
    #        for _ in range(speed): world.step(networks)
    #        Update _current_state (thread-safe)
    #        sleep(1/60) for ~60fps rendering
    # 4. car_stats = world.build_car_stats()  â€” snapshot each car's stats
    # 5. For each genome: genome.fitness = fitness_evaluator.evaluate(car_stats[i])

    # Polling (called from JS via api)
    get_state() -> dict
    # Returns:
    # {
    #   "cars": [[x, y, angle, alive, fitness], ...],
    #   "rays": [[[x1,y1,x2,y2], ...], ...] or None,
    #   "generation": 42,
    #   "alive_count": 156,
    #   "best_fitness": 8945.2,
    #   "species_count": 8,
    #   "history": [{"gen": 1, "best": 100, "avg": 50}, ...]
    # }

    # Checkpoint
    save_checkpoint() -> str                 # Manual save, returns filepath
```

### 5.8 `training/exporter.py` â€” Model Export/Import

```python
class Exporter:

    @staticmethod
    export_racer(
        genome: neat.DefaultGenome,
        car_config: CarConfig,
        neat_config: neat.Config,
        name: str = None,                   # Defaults to car_config.name + "_GenN"
        generation: int,
        species_count: int,
        track_name: str
    ) -> str                                 # Returns filepath of .racer file

    @staticmethod
    import_racer(filepath: str) -> dict
    # Returns:
    # {
    #   "name": "MyRacer",
    #   "car_config": CarConfig,
    #   "network": neat.nn.FeedForwardNetwork,
    #   "genome_data": dict,
    #   "metadata": dict
    # }

    @staticmethod
    genome_to_dict(genome: neat.DefaultGenome) -> dict     # Serialize genome
    dict_to_genome(data: dict, config: neat.Config) -> neat.DefaultGenome  # Deserialize
```

### 5.9 `training/config_bridge.py` â€” Config â†” UI

```python
class ConfigBridge:
    """Translates between UI form values and .ini config files"""

    @staticmethod
    read_car_config(filepath: str) -> dict           # INI â†’ dict for JS form
    write_car_config(filepath: str, values: dict)    # JS form â†’ INI

    @staticmethod
    read_neat_config(filepath: str) -> dict          # INI â†’ dict for JS form
    write_neat_config(filepath: str, values: dict)   # JS form â†’ INI

    @staticmethod
    get_editable_neat_params() -> list[dict]
    # Returns metadata for each user-editable parameter:
    # [
    #   {"key": "pop_size", "label": "Population Size", "type": "int",
    #    "min": 10, "max": 1000, "default": 200, "section": "NEAT",
    #    "tooltip": "Number of genomes per generation",
    #    "resume_safe": True},
    #   {"key": "ray_count", "label": "Ray Count", "type": "int",
    #    "min": 1, "max": 20, "default": 5, "section": "car",
    #    "tooltip": "Number of sensor rays",
    #    "resume_safe": False},  # â† Can NOT change on resume
    #   {"key": "drift_enabled", "label": "Drift", "type": "bool",
    #    "default": false, "section": "car",
    #    "tooltip": "Enable drift mechanics (adds drift angle input to network)",
    #    "resume_safe": False},  # â† Can NOT change on resume
    #   ...
    # ]

    @staticmethod
    validate_for_resume(
        new_config: dict,
        checkpoint_config: dict
    ) -> dict
    # Returns {"valid": True/False, "errors": ["ray_count changed from 5 to 7", "drift_enabled changed"]}
```

### 5.10 `race/race_manager.py` â€” Race Mode

```python
class RaceManager:
    """Manages a race between exported models.
    Each racer has its own CarConfig (different speed, drift, grip, etc.)
    and its own neural network with potentially different num_inputs."""

    track: Track
    racers: list[dict]                       # Loaded racer data
    networks: list                           # NEAT networks (may have different topologies)
    car_configs: list[CarConfig]             # Each racer's own car config
    car_batches: list[CarBatch]              # One CarBatch(1) per racer (not shared)
    colors: list[str]                        # Assigned color per racer
    num_laps: int                            # Number of laps to complete (default 3)
    results: list[dict]                      # Lap times, positions
    running: bool
    finished: bool

    # Setup
    load_race(
        track_path: str,
        racer_paths: list[str],             # List of .racer file paths
        num_laps: int = 3
    ) -> dict                                # Returns racer info for display
    # Steps:
    # 1. Load track
    # 2. For each .racer file:
    #    - Load car_config (may have drift_enabled=True or False)
    #    - Rebuild NEAT network from genome with matching config
    #    - Create CarBatch(1) with this racer's CarConfig
    # 3. Assign distinct colors
    # 4. Validate all racers can run on this track (start pos exists, etc.)

    # Race loop
    start()                                  # Launch race in thread
    _race_thread()
    # Loop:
    # For each racer independently:
    #   1. inputs = car_batches[i].get_nn_inputs(track, car_configs[i])
    #   2. output = networks[i].activate(inputs[0])
    #   3. car_batches[i].update(steering, throttle, car_configs[i])
    #   4. car_batches[i].check_grass(track)
    #   5. car_batches[i].check_checkpoints(track.checkpoints)
    # Update rankings (who is furthest ahead in lap/checkpoint progress)
    # Check for finish (first racer to complete num_laps wins)
    #
    # CRASH BEHAVIOR:
    # - A car that touches grass gets a DNF (Did Not Finish)
    # - Crashed cars stop moving and are grayed out on canvas
    # - Race continues for remaining alive racers
    # - If all cars crash, race ends â€” rankings by furthest progress
    # - DNF cars are ranked below finishers, ordered by checkpoint progress

    get_state() -> dict
    # Returns:
    # {
    #   "cars": [{"name": "Racer1", "x": .., "y": .., "angle": ..,
    #             "velocity_angle": .., "drift_enabled": true,
    #             "color": "#FF0000", "alive": true,
    #             "lap": 2, "checkpoint": 5}, ...],
    #   "rankings": [{"name": "Racer1", "lap": 2, "time": 45.2, "dnf": false}, ...],
    #   "finished": False
    # }

    stop()
    reset()
```

---

## 6. Frontend Architecture

### 6.1 `web/index.html` â€” Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [Track Editor]  [Training]  [Race]              â† Tab bar       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                          â”‚                       â”‚
â”‚                                          â”‚   SIDE PANEL           â”‚
â”‚                                          â”‚                       â”‚
â”‚          MAIN CANVAS                     â”‚   (context-dependent)  â”‚
â”‚          (track + cars)                  â”‚                       â”‚
â”‚                                          â”‚   Editor: tools        â”‚
â”‚                                          â”‚   Training: stats      â”‚
â”‚                                          â”‚   Race: leaderboard    â”‚
â”‚                                          â”‚                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  BOTTOM BAR: status info, speed slider, generation counter       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 `web/js/app.js` â€” App Controller

```javascript
class App {
    mode: string                            // "editor" | "training" | "race"
    canvas: HTMLCanvasElement
    ctx: CanvasRenderingContext2D

    init()                                  // Setup canvas, event listeners, load defaults
    switchMode(mode: string)                // Show/hide relevant panels
    startPolling()                          // requestAnimationFrame loop
    stopPolling()
}
```

### 6.3 `web/js/canvas.js` â€” Rendering Engine

```javascript
class Renderer {
    canvas: HTMLCanvasElement
    ctx: CanvasRenderingContext2D
    trackImage: ImageBitmap                 // Cached track background
    carSprites: Map<string, Image>          // Car images by color/name
    showRays: boolean
    camera: {x, y, zoom}                    // Pan & zoom support

    // Track
    drawTrack()                             // Blit track background image
    drawCheckpoints(checkpoints: Array)     // Draw checkpoint lines (numbered)
    drawStartPosition(start: Object)        // Draw start marker + direction arrow

    // Training mode
    drawCars(cars: Array)                   // Draw all car sprites at positions
    // Each car: rotated rectangle/image, colored by alive/dead
    // Green = alive, Red = dead (faded), Blue = best fitness

    drawRays(rays: Array)                   // Draw ray lines from each alive car
    // Color: green (far from grass) â†’ red (close to grass edge)

    // Race mode
    drawRaceCars(cars: Array)               // Draw race cars with name labels + colors
    // Cars with drift enabled: draw rotated sprite (heading) + velocity arrow
    // Shows visual drift when heading â‰  velocity direction
    drawRankings(rankings: Array)           // Overlay leaderboard on canvas

    // Utilities
    clear()
    worldToScreen(x, y) -> {x, y}          // Apply camera transform
    screenToWorld(x, y) -> {x, y}          // Inverse camera transform
}
```

### 6.4 `web/js/editor.js` â€” Track Editor

```javascript
class Editor {
    tool: string                            // "road" | "erase" | "checkpoint" | "start" | "select"
    brushSize: int                          // For road/erase painting
    isDrawing: boolean
    roadCanvas: OffscreenCanvas             // Drawing layer (green bg, gray road)
    roadCtx: OffscreenCanvasRenderingContext2D
    checkpoints: Array                      // [{x1, y1, x2, y2, index}]
    startPos: {x, y, angle}
    undoStack: Array
    redoStack: Array

    GRASS_COLOR: "#4CAF50"                  // Green grass (death zone)
    ROAD_COLOR: "#808080"                   // Gray road (safe zone)

    // Init
    initCanvas(width, height)               // Fill entire canvas with GRASS_COLOR
    loadFromTrack(trackData)                // Load saved track for editing

    // Tools
    setTool(tool: string)
    setBrushSize(size: int)

    // Drawing
    onMouseDown(e)                          // Start drawing/placing
    onMouseMove(e)                          // Continue drawing
    onMouseUp(e)                            // End drawing, push undo

    // Paint road mode
    paintRoad(x, y)                         // Paint gray circle (road) at position
    eraseRoad(x, y)                         // Paint green circle (grass) at position

    // Checkpoint mode
    startCheckpoint(x, y)                   // Begin placing gate (click first point)
    endCheckpoint(x, y)                     // Finish gate line (click second point)
    moveCheckpoint(index, dx, dy)           // Drag to reposition
    deleteCheckpoint(index)
    reorderCheckpoints()                    // Renumber after changes

    // Start position mode
    placeStart(x, y)                        // Set position
    rotateStart(angle)                      // Set direction (scroll wheel or drag)

    // Undo/Redo
    pushUndo()                              // Snapshot roadCanvas + checkpoints + start
    undo()
    redo()

    // Clear
    clearAll()                              // Reset to full green, remove checkpoints

    // Save/Load
    getTrackData() -> Object                // Package road mask + checkpoints + start
    loadTrackData(data: Object)             // Load saved track into editor for editing
    getRoadMaskBase64() -> string           // Export road canvas as base64 PNG
}
```

### 6.5 `web/js/training.js` â€” Training Controls

```javascript
class TrainingUI {
    isRunning: boolean
    isPaused: boolean
    pollInterval: int                       // requestAnimationFrame ID

    // Controls
    startTraining()                         // Call api.start_training()
    pauseTraining()                         // Call api.pause_training()
    resumeTraining()                        // Call api.resume_training()
    stopTraining()                          // Call api.stop_training()
    setSpeed(value: int)                    // Call api.set_speed()
    toggleRays(visible: bool)              // Call api.toggle_rays()
    saveCheckpoint()                        // Call api.save_checkpoint()
    exportBest()                            // Call api.export_best_racer()

    // Polling loop
    pollState()
    // 1. state = await pywebview.api.get_training_state()
    // 2. renderer.drawTrack()
    // 3. renderer.drawCars(state.cars)
    // 4. if showRays: renderer.drawRays(state.rays)
    // 5. updateStatsPanel(state)
    // 6. updateChart(state.history)
    // 7. requestAnimationFrame(pollState)

    // Stats display
    updateStatsPanel(state: Object)         // Generation, alive, best fitness, species
}
```

### 6.6 `web/js/config_panel.js` â€” Configuration Forms

```javascript
class ConfigPanel {
    carConfig: Object                       // Current car config values
    neatConfig: Object                      // Current NEAT config values
    paramMeta: Array                        // Parameter metadata (types, ranges, tooltips)

    // Init
    async loadConfigs()                     // Fetch current configs from Python
    async loadParamMetadata()               // Fetch editable params info
    renderCarForm()                         // Generate car config form HTML
    renderNeatForm()                        // Generate NEAT config form HTML

    // Events
    onCarConfigChange(key, value)           // Update local state
    onNeatConfigChange(key, value)          // Update local state
    async saveCarConfig()                   // Push to Python â†’ save .ini
    async saveNeatConfig()                  // Push to Python â†’ save .ini

    // Resume validation
    async validateForResume() -> Object     // Check if configs are compatible
    highlightIncompatible(errors: Array)    // Red-border on incompatible fields
}
```

### 6.7 `web/js/race.js` â€” Race Mode

```javascript
class RaceUI {
    racers: Array                           // Loaded racer info
    isRunning: boolean

    // Setup
    async loadTrack()                       // File picker â†’ load .track
    async addRacer()                        // File picker â†’ load .racer, display config summary
    removeRacer(index)
    getRacerList() -> Array                 // Display loaded racers with config (drift, speed, etc.)

    // Race
    async startRace()                       // Send track + racers to Python
    stopRace()

    // Polling loop
    pollRaceState()
    // 1. state = await pywebview.api.get_race_state()
    // 2. renderer.drawTrack()
    // 3. renderer.drawRaceCars(state.cars)
    // 4. renderer.drawRankings(state.rankings)
    // 5. if state.finished: showResults()

    // Results
    showResults()                           // Final leaderboard overlay
}
```

### 6.8 `web/js/fitness_editor.js` â€” Fitness Code Editor

```javascript
class FitnessEditor {
    textarea: HTMLTextAreaElement            // Monospace code textarea
    statusEl: HTMLElement                    // "âœ… Valid" or "âŒ Error on line 3: ..."
    code: string                            // Current fitness function source

    // Init
    async loadCode()                        // Fetch current code from Python API
    renderEditor()                          // Build textarea + buttons in panel

    // Events
    onCodeChange()                          // Update local code state
    async validate()                        // Call api.set_fitness_code() â†’ show status
    async resetDefault()                    // Call api.reset_fitness_code() â†’ reload

    // Status display
    showValid()                             // Green checkmark
    showError(error: string)                // Red X + error message with line number
}
```

### 6.9 `web/js/chart.js` â€” Fitness Chart

```javascript
class FitnessChart {
    canvas: HTMLCanvasElement
    ctx: CanvasRenderingContext2D
    data: Array                             // [{gen, best, avg, worst}]

    update(history: Array)                  // Append new data points
    draw()                                  // Render line chart
    // Lines: best fitness (green), average fitness (blue), worst (red, optional)
    // X axis: generation, Y axis: fitness
    // Auto-scaling Y axis

    clear()                                 // Reset chart
}
```

---

## 7. UI Panels Detail

### 7.1 Editor Side Panel

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ TRACK EDITOR              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Tools:                    â•‘
â•‘ [ğŸ–Œ Road] [ğŸ§¹ Erase]      â•‘
â•‘ [ğŸ“ Checkpoint] [ğŸš© Start] â•‘
â•‘                           â•‘
â•‘ Brush Size: [====â—===] 20 â•‘
â•‘                           â•‘
â•‘ Checkpoints: 5            â•‘
â•‘  â˜‘ 1  â˜‘ 2  â˜‘ 3  â˜‘ 4  â˜‘ 5 â•‘
â•‘  [Delete Selected]        â•‘
â•‘                           â•‘
â•‘ [Undo] [Redo] [Clear All] â•‘
â•‘                           â•‘
â•‘ â”€â”€â”€ File â”€â”€â”€              â•‘
â•‘ [Save Track] [Load Track] â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### 7.2 Training Side Panel

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ TRAINING                  â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Status: â— Running         â•‘
â•‘                           â•‘
â•‘ [â–¶ Start] [â¸ Pause] [â¹ Stop] â•‘
â•‘                           â•‘
â•‘ Speed: [====â—=======] x5  â•‘
â•‘ â˜‘ Show Rays               â•‘
â•‘                           â•‘
â•‘ â”€â”€â”€ Stats â”€â”€â”€             â•‘
â•‘ Generation:    42          â•‘
â•‘ Alive:         156 / 200   â•‘
â•‘ Best Fitness:  8,945       â•‘
â•‘ Avg Fitness:   2,341       â•‘
â•‘ Species:       8           â•‘
â•‘                           â•‘
â•‘ â”€â”€â”€ Fitness Graph â”€â”€â”€     â•‘
â•‘ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â•‘
â•‘ â”‚  ğŸ“ˆ (chart canvas)   â”‚   â•‘
â•‘ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â•‘
â•‘                           â•‘
â•‘ â”€â”€â”€ Actions â”€â”€â”€           â•‘
â•‘ [Save Checkpoint]         â•‘
â•‘ [Export Best Model]       â•‘
â•‘ [Load Checkpoint â–¾]      â•‘
â•‘                           â•‘
â•‘ â”€â”€â”€ Car Config â”€â”€â”€        â•‘
â•‘ Name:         [ MyCar  ]  â•‘
â•‘ Max Speed:    [  10.0  ]  â•‘
â•‘ Acceleration: [   0.5  ]  â•‘
â•‘ Brake Force:  [   0.8  ]  â•‘
â•‘ Rotation:     [   4.0  ]  â•‘
â•‘ Drift:        [ON/OFF ] ğŸ”’â•‘
â•‘ Grip:         [   0.7  ]  â•‘
â•‘ (grip only when drift ON) â•‘
â•‘ Rays:         [  5     ] ğŸ”’â•‘
â•‘ Ray Length:   [ 200    ]  â•‘
â•‘ Ray Spread:   [ 180Â°   ]  â•‘
â•‘ Max Ticks:    [ 2000   ]  â•‘
â•‘ Stall Timeout:[ 200    ]  â•‘
â•‘ ğŸ”’ = cannot change on     â•‘
â•‘     resume (topology)     â•‘
â•‘                           â•‘
â•‘ â”€â”€â”€ NEAT Config â”€â”€â”€       â•‘
â•‘ Population:   [  200   ]  â•‘
â•‘ Compat Thresh:[  3.0   ]  â•‘
â•‘ Conn Add Rate:[  0.5   ]  â•‘
â•‘ Node Add Rate:[  0.2   ]  â•‘
â•‘ Weight Mut:   [  0.8   ]  â•‘
â•‘ Survival:     [  0.2   ]  â•‘
â•‘ Max Stagnation:[ 20    ]  â•‘
â•‘ Elitism:      [  2     ]  â•‘
â•‘ [Apply Config Changes]    â•‘
â•‘                           â•‘
â•‘ â”€â”€â”€ Fitness Function â”€â”€â”€  â•‘
â•‘ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘
â•‘ â”‚def fitness(car):      â”‚ â•‘
â•‘ â”‚  score = 0.0          â”‚ â•‘
â•‘ â”‚  score += car.total_  â”‚ â•‘
â•‘ â”‚    checkpoints * 1000 â”‚ â•‘
â•‘ â”‚  ...                  â”‚ â•‘
â•‘ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘
â•‘ [Validate] [Reset Default]â•‘
â•‘ Status: âœ… Valid           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### 7.3 Race Side Panel

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ RACE                      â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Track: oval_track.track   â•‘
â•‘ [Change Track]            â•‘
â•‘                           â•‘
â•‘ Laps: [  3  ]             â•‘
â•‘                           â•‘
â•‘ â”€â”€â”€ Racers â”€â”€â”€            â•‘
â•‘ ğŸ”´ SpeedDemon (Gen 42)    â•‘
â•‘    drift: OFF  spd: 10    â•‘
â•‘ ğŸ”µ TankMode (Gen 100)     â•‘
â•‘    drift: ON   grip: 0.7  â•‘
â•‘ ğŸŸ¢ DriftKing (Gen 67)     â•‘
â•‘    drift: ON   grip: 0.3  â•‘
â•‘ [+ Add Racer]             â•‘
â•‘ [Remove Selected]         â•‘
â•‘                           â•‘
â•‘ [ğŸ Start Race]           â•‘
â•‘                           â•‘
â•‘ â”€â”€â”€ Leaderboard â”€â”€â”€       â•‘
â•‘ 1. ğŸ”µ TankMode     1:23.4 â•‘
â•‘ 2. ğŸ”´ SpeedDemon   1:25.1 â•‘
â•‘ 3. ğŸŸ¢ DriftKing    Lap 2  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### 7.4 Bottom Bar

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Mode: Training â”‚ Gen: 42 â”‚ Alive: 156/200 â”‚ Best: 8,945 â”‚ FPS: 60 â”‚ Speed: x5 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 8. Data Flow

### 8.1 Training Loop Sequence

```
JS (requestAnimationFrame loop)          Python (background thread)
â”‚                                         â”‚
â”‚                                         â”‚ â† NEAT calls _eval_genomes()
â”‚                                         â”‚    reset_generation(pop_size)
â”‚                                         â”‚    â”Œâ”€loopâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                         â”‚    â”‚ for _ in range(speed):â”‚
â”‚                                         â”‚    â”‚   inputs = nn_inputs()â”‚
â”‚                                         â”‚    â”‚   out = net(inputs)   â”‚
â”‚                                         â”‚    â”‚   cars.update()       â”‚
â”‚                                         â”‚    â”‚   check_grass()        â”‚
â”‚                                         â”‚    â”‚   check_checkpoints() â”‚
â”‚                                         â”‚    â”‚   update_wall_stats() â”‚
â”‚                                         â”‚    â”‚   update_dist_to_cp() â”‚
â”‚   state = api.get_training_state() â”€â”€â–º  â”‚    â”‚   update _state â”€â”€â”€â”€â”€â”€â”¤â”€â”€â–º return state
â”‚   â—„â”€â”€â”€ {cars, rays, stats}              â”‚    â”‚                       â”‚
â”‚   drawTrack()                           â”‚    â”‚ sleep(1/60)           â”‚
â”‚   drawCars(state.cars)                  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚   drawRays(state.rays)                  â”‚    build_car_stats()
â”‚   updateStats(state)                    â”‚    fitness_evaluator.evaluate() per car
â”‚   updateChart(state.history)            â”‚    NEAT does selection/mutation
â”‚   requestAnimationFrame(poll)           â”‚
```

### 8.2 Stop â†’ Config Change â†’ Resume Flow

```
User clicks [Pause] â”€â”€â–º api.pause_training()
                         trainer.paused = True
                         training thread: while paused: sleep

User edits car_config   (Max Speed: 10 â†’ 15)
User edits neat_config  (Pop Size: 200 â†’ 300)

User clicks [Apply Config Changes]
  â”€â”€â–º api.set_car_config(new_values)
      api.set_neat_config(new_values)
      ConfigBridge.validate_for_resume()
        â†’ Check ray_count unchanged âœ“
        â†’ Check drift_enabled unchanged âœ“
        â†’ Check num_outputs unchanged âœ“
        â†’ Return {valid: True}

User clicks [Resume] â”€â”€â–º api.resume_training()
  (or actually: stop current + resume from latest checkpoint with new config)
  1. trainer.stop()
  2. Save checkpoint
  3. Reload configs from .ini
  4. trainer.resume(checkpoint, new_car_config, new_neat_config)
```

---

## 9. Fitness Function (User-Defined)

The user writes a custom Python fitness function in a code editor embedded in the training panel.
A default function is provided but fully editable.

### Available Variables

The function receives a `car` object with these read-only attributes:

| Variable | Type | Description |
|----------|------|-------------|
| `car.checkpoints_reached` | int | Number of checkpoints passed in current lap |
| `car.total_checkpoints` | int | Total checkpoints crossed including previous laps |
| `car.laps` | int | Full laps completed |
| `car.time_alive` | int | Ticks survived before crash/timeout |
| `car.total_time` | int | Max ticks allowed per generation |
| `car.total_distance` | float | Odometer â€” total distance traveled |
| `car.average_speed` | float | Mean speed over lifetime |
| `car.max_speed_reached` | float | Peak speed achieved |
| `car.current_speed` | float | Speed at death/end |
| `car.distance_to_next_cp` | float | How close to next checkpoint (lower = closer) |
| `car.drift_count` | int | Ticks spent drifting (heading â‰  velocity). 0 if drift OFF |
| `car.is_alive` | bool | Whether the car is still alive |
| `car.crashed` | bool | Whether the car died by hitting grass/wall |
| `car.timed_out` | bool | Whether the car was killed by stall/timeout |
| `car.wall_hits` | int | Number of ticks the car was touching grass edge (grazing) |
| `car.min_wall_distance` | float | Closest the car ever got to grass edge (0 = touching) |
| `car.avg_wall_distance` | float | Average distance to nearest grass over lifetime |

### Default Fitness Function

```python
def fitness(car):
    score = 0.0
    
    # Reward checkpoint progress (main signal)
    score += car.total_checkpoints * 1000
    
    # Reward getting closer to next checkpoint
    score += (1.0 - car.distance_to_next_cp) * 500
    
    # Reward completing laps
    score += car.laps * 10000
    
    # Reward average speed
    score += car.average_speed * 10
    
    # Reward staying away from walls (safer driving)
    score += car.avg_wall_distance * 2
    
    return score
```

### Example: Aggressive Racer

```python
def fitness(car):
    # Only care about speed and checkpoints, ignore safety
    return car.total_checkpoints * 500 + car.max_speed_reached * 100
```

### Example: Safe Driver

```python
def fitness(car):
    # Reward smooth driving, penalize wall proximity
    score = car.total_checkpoints * 1000
    score += car.avg_wall_distance * 50
    score -= car.wall_hits * 10
    if car.crashed:
        score *= 0.5  # Harsh penalty for crashing
    return score
```

### Implementation

The user's code is stored as a string and executed via Python's `exec()`:

```python
# In trainer.py
class FitnessEvaluator:
    code: str                               # User's fitness function source code
    _compiled: callable                     # Compiled function

    set_code(code: str) -> dict
    # 1. Try to compile the code
    # 2. Test with a dummy CarStats object
    # 3. Return {"valid": True} or {"valid": False, "error": "line 3: NameError..."}

    evaluate(car_stats: CarStats) -> float
    # Calls the user's function with car_stats
    # Wrapped in try/except â€” returns 0.0 on error

class CarStats:
    """Read-only snapshot of car state, passed to fitness function as `car`"""
    checkpoints_reached: int
    total_checkpoints: int
    laps: int
    time_alive: int
    total_time: int
    total_distance: float
    average_speed: float
    max_speed_reached: float
    current_speed: float
    distance_to_next_cp: float
    drift_count: int
    is_alive: bool
    crashed: bool                           # Died by hitting grass
    timed_out: bool                         # Died by stall timeout
    wall_hits: int                          # Ticks spent grazing grass edge
    min_wall_distance: float                # Closest approach to grass
    avg_wall_distance: float                # Average distance to nearest grass
```

### Safety

Since this is a local desktop app (not a server), `exec()` is acceptable.
The code runs in a restricted namespace with only `car` and basic math available:

```python
namespace = {
    "car": car_stats,
    "abs": abs, "min": min, "max": max,
    "pow": pow, "round": round,
    "__builtins__": {}  # No imports, no file access
}
```

---

## 10. Threading Model

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Main Thread      â”‚
â”‚   (PyWebView)      â”‚
â”‚                    â”‚
â”‚   Handles:         â”‚
â”‚   - Window events  â”‚
â”‚   - JS â†” Python    â”‚
â”‚     API calls      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ api calls
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Training Thread   â”‚
â”‚  (daemon thread)   â”‚
â”‚                    â”‚
â”‚  Handles:          â”‚
â”‚  - NEAT loop       â”‚
â”‚  - Simulation      â”‚
â”‚  - State updates   â”‚
â”‚                    â”‚
â”‚  Shared via:       â”‚
â”‚  _lock + _state    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- **Main thread**: PyWebView event loop + API call handling
- **Training thread**: NEAT + simulation loop (daemon, stops when main exits)
- **Synchronization**: `threading.Lock` around `_current_state` dict
- **Communication**: JS polls `get_training_state()` via `requestAnimationFrame` â†’ Python returns latest snapshot

---

## 11. Key Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Sim engine | NumPy vectorized | 100x faster than per-car loops for 300+ cars |
| Rendering | HTML5 Canvas via PyWebView | CPU-compatible, great UI primitives, no GPU needed |
| Communication | Direct function binding | No network, no sockets, cannot break |
| NEAT library | neat-python 1.1.0 | Mature, config-file based, checkpointing built-in |
| Config format | INI files | NEAT-Python native format, human readable |
| Export format | JSON | Human readable, framework-agnostic (NEAT-Python 1.1 feature) |
| Threading | 1 background thread | Simple, avoids GIL issues (NumPy releases GIL) |
| Track storage | Road mask (PNG) | Fastest for collision: array[y, x] lookup. Green=grass(death), Gray=road(safe) |
| Raycasting | DDA / step march on mask | Vectorizable, O(ray_length) per ray |
| Neural inputs | rays + speed + heading + accel + (drift) | Full car state awareness, all normalized [-1,1] or [0,1] |
| Race physics | Each racer has own CarConfig + CarBatch(1) | Supports mixed drift on/off, different speeds, grips |
| Car collision | No car-to-car collision (cars pass through each other) | Simplicity; NEAT only learns track navigation, not avoidance |
| Car hitbox | Fixed 30Ã—15px for all cars | Fair races â€” AI skill matters, not car size |
| Package manager | uv | Fast, cross-platform, lockfile for reproducible installs |
| Fitness | User-defined Python function via code editor | Full control; default rewards checkpoints + speed + wall safety |
| Resume | NEAT Checkpointer | Built-in, saves full population state |

---

## 12. Implementation Order

### Phase 1 â€” Core Simulation (no UI)
1. `uv init` + `pyproject.toml` â€” Project setup with dependencies
2. `simulation/track.py` â€” Road mask (green=grass/death, gray=road/safe), load from image
3. `simulation/car.py` â€” CarConfig, CarBatch with vectorized physics + drift
4. `simulation/checkpoint.py` â€” Gate intersection logic
5. `simulation/world.py` â€” World: tie together track + cars + checkpoints
6. Unit tests: cars drive, die on grass, cross checkpoints

### Phase 2 â€” NEAT Integration
7. `training/config_bridge.py` â€” INI read/write
8. `training/trainer.py` â€” NEAT loop with eval_genomes + FitnessEvaluator
9. `training/exporter.py` â€” Save/load genomes as JSON
10. Test: headless training on a simple oval track

### Phase 3 â€” PyWebView + Basic UI
11. `main.py` + `api.py` â€” Window + API bridge
12. `web/index.html` + `style.css` â€” Layout scaffold
13. `web/js/app.js` â€” Mode switching
14. `web/js/canvas.js` â€” Renderer: draw track + cars
15. `web/js/training.js` â€” Start/stop + polling loop
16. Test: watch cars train on a hardcoded track

### Phase 4 â€” Track Editor
17. `web/js/editor.js` â€” Paint road (green bg â†’ gray road), erase, checkpoints, start
18. API: save_track / load_track / edit loaded track
19. Undo/redo (canvas snapshots)
20. Clear all

### Phase 5 â€” Config & Polish
21. `web/js/config_panel.js` â€” Car + NEAT config forms
22. `web/js/fitness_editor.js` â€” Fitness function code editor + validation
23. `web/js/chart.js` â€” Fitness chart
24. Stop/resume with config changes
25. Checkpoint management (save/load/list)

### Phase 6 â€” Race Mode
26. `race/race_manager.py` â€” Race logic
27. `web/js/race.js` â€” Race UI
28. Racer import, simultaneous race, leaderboard

### Phase 7 â€” Polish
29. Camera pan/zoom on canvas
30. Keyboard shortcuts
31. Error handling & edge cases
32. Default example tracks
33. README + setup instructions (uv install guide for Windows/macOS/Linux)